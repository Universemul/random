<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="949.43">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 12.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 12.0px Helvetica; min-height: 14.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
  </style>
</head>
<body>
<p class="p1"><b>Project 4 Corrections and Clarifications</b></p>
<p class="p1"><b>Updated 3/19/09</b></p>
<p class="p1"><b>Most recent items appear first</b></p>
<p class="p1"><b>Page numbers refer to the pdf document</b></p>
<p class="p2"><br></p>
<p class="p1"><b>NOTICE:</b></p>
<p class="p1"><b>This document is part of the project specifications.</b></p>
<p class="p1"><b>Your solution must follow these corrections and clarifications.</b></p>
<p class="p3"><br></p>
<p class="p3"><b></b><br></p>
<p class="p4"><b>P. 8. Peasant::start_working first resets both moving and working states.</b></p>
<p class="p4"><i>Change:</i></p>
<p class="p4">start_working. First stop moving.<span class="Apple-converted-space">Â </span></p>
<p class="p4"><i>To:</i></p>
<p class="p4">start_working. First stop moving with Agent::stop() and then set the state to Not_working and reset the source and destination pointers.</p>
<p class="p3"><b></b><br></p>
<p class="p4"><b>P. 11, skeleton_Controller.h. Controller can detach and destroy the view in a destructor.</b></p>
<p class="p4"><i>Change:</i></p>
<p class="p4">When Controller terminates, it detaches the View from the model, and then deletes it.</p>
<p class="p4"><i>To:</i></p>
<p class="p4">When Controller terminates, it detaches the View from the model, and then deletes it, or these actions can be done in the Controller destructor.</p>
<p class="p3"><br></p>
<p class="p4">If you want to use the destructor, you may add a destructor function to Controller.</p>
<p class="p3"><br></p>
<p class="p4"><b>P. 11. Model-View-Controller Interaction, third paragraph. Introductory description of View-Model update location process is garbled.</b></p>
<p class="p4"><i>Change</i>:</p>
<p class="p4">In this version, Model updates the View by calling View::update_location() for the Sim_objects, using a pure "push" pattern of interaction - information is pushed from the Model to the View; in this version, the View does not "pull" information from the Model. Model does this View update on the following occasions:</p>
<p class="p4"><i>To</i>:</p>
<p class="p4">Model updates the View by calling View::update_location() for Sim_objects, using a pure "push" pattern of interaction - information is pushed from the Model to the View. Model does this View update on the following occasions:</p>
<p class="p3"><br></p>
<p class="p4"><b>P.12. Caption for figure is incorrect.</b></p>
<p class="p4"><i>Change</i>:</p>
<p class="p4">and then gets the location from each Sim_object</p>
<p class="p4"><i>To</i>:</p>
<p class="p4">and then gets the location from each Agent</p>
<p class="p3"><br></p>
<p class="p4"><b>P. 8. Clarification of Peasant::start_working() and its call of move_to().</b></p>
<p class="p4">See the earlier description of Peasant::move_to in the previous paragraph, about how Peasant::move_to needs to work different;y than Agent's move_to. Consequently, Peasant::start_working() can't call Peasant::move_to() to set up to move to a destination, but instead has to call Agent::move_to().</p>
<p class="p3"><br></p>
<p class="p4"><i>In the paragraph describing start_working, change:</i></p>
<p class="p4">Otherwise, if the amount we are carrying is greater than zero, command ourselves (with move_to) to go to the destination and set the state to Outbound.</p>
<p class="p4"><i>To:</i></p>
<p class="p4">Otherwise, if the amount we are carrying is greater than zero, command ourselves (with Agent::move_to) to go to the destination and set the state to Outbound.</p>
<p class="p3"><br></p>
<p class="p4">Also, "sample" in that same paragraph should be "same".</p>
<p class="p3"><br></p>
<p class="p4"><b>P. 7, 11, 12. Inconsistent specification for when Controller creates and attaches the View.</b></p>
<p class="p4">This is a result of the design getting out of sync with the document. P. 7 and 12 say that Controller's constructor does this, while P. 11 says that Controller:run() does it. Either one will produce the same stream of output and component behavior.</p>
<p class="p3"><br></p>
<p class="p4">However, in the next project, no View will be initially constructed by default, and user commands will open and close all of the Views, and these commands will be handled as subfunctions called by Controller::run(). So placing the first View opening in the run() function in this project, as stated on P. 11, is closer to what we will do later.</p>
<p class="p3"><br></p>
<p class="p4">Accordingly, do the following:</p>
<p class="p4"><i>P. 7. Change:</i></p>
<p class="p4">When Controller is created, it creates the View object and attaches it to Model,</p>
<p class="p4"><i>To:</i></p>
<p class="p4">When Controller::run() first starts executing, it creates the View object and attaches it to Model,</p>
<p class="p3"><br></p>
<p class="p4"><i>P. 12. Change:</i></p>
<p class="p4">The Controller constructor creates a View object, and attaches it to Model.</p>
<p class="p4"><i>To:</i></p>
<p class="p4">The Controller::run() function first creates a View object, and attaches it to Model.</p>
<p class="p3"><br></p>
<p class="p3"><br></p>
<p class="p4"><b>P. 4-5. Superseded description of Agent states - P. 4-5 doesn't agree with detailed description on P. 8.</b></p>
<p class="p4"><i>Change last sentence on P.4:</i></p>
<p class="p4">They also have a second set of states that represent whether the Agent is Alive, Dead, or Disappearing. If an Agent is killed or dies, it first becomes Dead, and then when next updated, becomes Disappearing.</p>
<p class="p3"><br></p>
<p class="p4"><i>To:</i></p>
<p class="p4">They also have a second set of states that represent whether the Agent is Alive, Dying, Dead, or Disappearing. If an Agent is killed or dies, it first becomes Dying, and then when next updated, becomes Dead, and when updated again becomes Disappearing and stays that way.</p>
<p class="p3"><br></p>
<p class="p4"><i>In first paragraph on P.5, change "three states" to "four states".</i></p>
<p class="p3"><br></p>
</body>
</html>
