<!--This file created by ClarisWorks HTML Filter 2.0-->
<HTML>
<HEAD>
<META NAME=GENERATOR CONTENT="ClarisWorks HTML Filter 2.0">
<TITLE>Operator_Overloading</TITLE>
</HEAD>
<BODY  >

<P ALIGN=CENTER><B>A Summary of Operator Overloading<BR>
</B><BR>
</P>

<P>This summary uses the CoinMoney example in the coursepack.  Variables m1, m2, etc are all assumed to be CoinMoney objects.  The Standard Library output streams also provide some examples.<BR>
<BR>
<B>Basic idea<BR>
</B><BR>
You overload an operator in C++ by defining a function for the operator.  This function takes at least one argument of your own type, and returns a value of whatever type that you want.<BR>
<BR>
You do this differently depending on whether the operator function is a member of your own type's class, or is a non-member function.  A further variation is whether the arguments are of the same or different types. We'll do this first for non-member functions, then for member functions.<BR>
<BR>
In schematic form, when you use a binary operator, there is a left-hand-side operand and a right-hand-side operand, and the whole expression has a value.<BR>
<BR>
lhs op rhs   --- has a value resulting from applying &quot;op&quot; to &quot;lhs&quot; and &quot;rhs&quot;<BR>
<BR>
The operator function's first argument is the lhs operand, and the second is the rhs operand.  The name of the operator function is &quot;operator op&quot;, where op is the operator, such as '+', '*', etc.<BR>
<BR>
<B>Non-member operator functions<BR>
</B><BR>
A non-member operator overloading function simply has the right name and does whatever you want. For example, suppose we want to add two CoinMoney objects and get a third CoinMoney object that has the sum of the nickles from the first two, etc.  We define the function named operator+ that takes two arguments of CoinMoney type and returns a CoinMoney object with the correct values.<BR>
<BR>
Let's use the example version of CoinMoney in which the member variables nickels, dimes, etc., are private. <BR>
<BR>
CoinMoney operator+ (CoinMoney lhs, CoinMoney rhs)<BR>
{<BR>
 CoinMoney sum;<BR>
 sum.set_nickels(lhs.get_nickels() + rhs.get_nickels() );<BR>
 ... etc ...<BR>
 return sum;<BR>
}<BR>
<BR>
This function creates a new object, gets the nickels value from the lhs and rhs objects, and sets the nickels of the new object to their sum.  Finally it returns the new object.<BR>
<BR>
So now we can write:<BR>
<BR>
 m3 = m1 + m2;<BR>
<BR>
The &quot;m1 + m2&quot; will be compiled into a call to our operator+ function that takes two CoinMoney objects as arguments.  It returns an object containing the sum, whose values then get copied into m3.  Because operator+ is just another function, the following two statements do exactly the same thing:<BR>
<BR>
 m3 = m1 + m2;<BR>
<BR>
 m3 = operator+ (m1, m2);<BR>
<BR>
Explicitly calling operator functions is legal, and is sometimes done in special circumstances, but why bother?  <BR>
<BR>
<B>Important: </B> C++ does not allow you to define overloaded operators where both arguments are built-in types like int, double, etc.  These operator definitions are fixed in the language.  Otherwise, you could  change integer addition into integer subtraction! Even C++ is not that crazy!<BR>
<BR>
<BR>
<B>Left- and right-hand operands can be different types<BR>
</B><BR>
At least one of the operator function parameters has to be of your type, but the other one can be of any other type, including a built-in type.  For example:<BR>
<BR>
CoinMoney operator* (CoinMoney lhs, double rhs)<BR>
{<BR>
 CoinMoney product;<BR>
 product.set_nickels( lhs.get_nickels() * rhs);<BR>
 etc<BR>
}<BR>
<BR>
This overload means that we can write:<BR>
<BR>
 m1 * 2.0;<BR>
<BR>
This gives us a CoinMoney object that has double the number of each type of coin as m1.<BR>
<BR>
Note that if we want to be able to write:<BR>
<BR>
 2.0 * m1;<BR>
<BR>
We also have to define CoinMoney operator* (double lhs, CoinMoney rhs).  The order of the argument types is different!<BR>
<BR>
<B>Avoiding reader/writer function calls<BR>
</B><BR>
If we don't like having to go through reader/writer functions to get at the private members, we can do two things:  Make the operator function a <I>friend</I> of the class, or make the operator function a member of the class.<BR>
<BR>
<B>Friend functions<BR>
</B><BR>
A class can declare that a specific function is its friend.  The friend now has access to the private members of the class.  This is easy to do.  Anywhere in the class declaration, put a statement of the form:<BR>
<BR>
friend your_function_prototype;<BR>
<BR>
For example:<BR>
<BR>
class CoinMoney<BR>
{<BR>
... blah blah ...<BR>
<BR>
friend CoinMoney operator+(CoinMoney lhs, CoinMoney rhs);<BR>
<BR>
... blah blah ...<BR>
}<BR>
<BR>
Now the operator function can be written with dot operators to get at the private member variables.<BR>
<BR>
CoinMoney operator+ (CoinMoney lhs, CoinMoney rhs)<BR>
{<BR>
 CoinMoney sum;<BR>
 sum.nickels = lhs.nickels + rhs.nickels;<BR>
 ... etc ...<BR>
 return sum;<BR>
}<BR>
<BR>
<B>Operator functions that are class member functions<BR>
</B><BR>
If you write an operator function as a member function, then it automatically has access to all of the member variables and functions of the class.  Friend declaration not needed! But the complication is that the left-hand-side operand becomes the &quot;implicit argument&quot; of the function - it is &quot;this&quot; object, the current one being worked on.  So the member operator function has only one argument, the right-hand-side operand.  For example, the overload operator function for + becomes:<BR>
<BR>
class CoinMoney<BR>
{<BR>
... blah blah ...<BR>
<BR>
CoinMoney operator+ (CoinMoney rhs)  //member function<BR>
{<BR>
 CoinMoney sum;<BR>
 sum.nickels = nickels + rhs.nickels;<BR>
 etc<BR>
 return sum;<BR>
}<BR>
... blah blah ...<BR>
};<BR>
<BR>
The naked &quot;nickels&quot; is the member variable in the left-hand-side operand, &quot;this&quot; object. The function has only one parameter, the right-hand-side operand. Because this function is a member of the class, it has direct access to the member variables in &quot;this&quot; current object, and dot access to the member variables in the other objects in the same class.<BR>
<BR>
Since a <I>member</I> operator function is just an ordinary <I>member</I> function, the following statements do the same thing:<BR>
<BR>
 m3 = m1 + m2;<BR>
<BR>
 m3 = m1.operator+ (m2);<BR>
<BR>
The member version of an operator function is called to work on the left-hand operand, with the right-hand operand being the function argument. Again, calling operator functions explicitly is legal, but rare, and usually pointless.<BR>
<BR>
<B>Left-hand operand for member operator functions must be the class type<BR>
<BR>
</B>As with non-member operator overload functions, you don't have to have both arguments be the same type.  However, by definition, the left-hand operand for a member operator function must be an object of the class that the function is a member of.  <BR>
<BR>
For example, suppose we wanted to be able to multiply CoinMoney objects by doubles as in the above example.  We can define operator* as a member function only if a CoinMoney object is the left-hand operand, but not if a double is the left-hand operand:<BR>
<BR>
That is, CoinMoney operator* (double x) can be defined as a member function of CoinMoney, and so<BR>
<BR>
m1.operator* (2.5);<BR>
<BR>
is a legal call.<BR>
<BR>
But you can't make a function a member of a class and then apply it as if it were a member of a different class.  For example, suppose foo was member function of the class Thing.<BR>
<BR>
class Thing<BR>
{<BR>
  void foo() {... blah blah ...}<BR>
};<BR>
<BR>
And we try to apply foo to the CoinMoney class which has no member function named foo:<BR>
<BR>
 m1.foo();   <BR>
<BR>
The compiler will say that there is no such member function for the class that m1 belongs to. So if operator* is defined in the CoinMoney class, <BR>
<BR>
my_double_variable.operator* (m1)  <BR>
<BR>
is illegal.  <BR>
<BR>
What do you do in such cases?  Simple: define this version of the operator overload using a non-member function. So for multiplying doubles and CoinMoney, we would have the following:<BR>
<BR>
class CoinMoney<BR>
{<BR>
... blah blah ...<BR>
// member function:<BR>
CoinMoney operator+ (double rhs) <BR>
{<BR>
... blah blah ...<BR>
}<BR>
... blah blah ...<BR>
};<BR>
<BR>
// non-member function:<BR>
CoinMoney operator+ (double lhs, CoinMoney rhs) <BR>
{<BR>
... blah blah ...<BR>
}<BR>
<BR>
The member function handles<BR>
<BR>
 m2 = m1 * my_double_variable;<BR>
<BR>
and the non-member function  handles<BR>
<BR>
 m2 = my_double_variable * m1;<BR>
<BR>
<B>Which operators can and should be overloaded? <BR>
</B><BR>
Almost all of the operators can be overloaded. But that doesn't mean you <I>should</I> overload them!  Good OOP practice is to overload operators for a class only when they make obvious sense. For example, what would less-than mean for CoinMoney?<BR>
<BR>
 m1 &lt; m2<BR>
<BR>
There are several reasonable ways that one collection of coins could be considered to be less than another - total number, total value, number of highest value coin, even total weight!  Finally, there is no clue what some operators might mean, such as:<BR>
<BR>
 (m1 % m2++) | m3<BR>
<BR>
Note that you don't have to define both &quot;ways&quot; for an overloaded operator.  For example, maybe you want half the coins in a CoinMoney object:<BR>
<BR>
 m1 / 2.0     <BR>
<BR>
This might make sense, but why would you want to divide by a CoinMoney object?<BR>
<BR>
 2.0 / m1  ???<BR>
<BR>
You only have to define the versions of the overloads that make sense and that you want to be able to use.  <BR>
<BR>
<BR>
<B>How do I overload the output operator to output objects of my own type?<BR>
</B><BR>
Just like any other operator, but you have to get certain things right.   Here's the basic pattern to allow you to output CoinMoney objects like any other type, as in<BR>
<BR>
cout &lt;&lt; m1 &lt;&lt; &quot;Hello!&quot; &lt;&lt; my_int;  // etc<BR>
<BR>
ostream&amp; operator&lt;&lt; (ostream&amp; os, CoinMoney x)<BR>
{<BR>
 os &lt;&lt; /* whatever you want to output about x */;<BR>
 return os;<BR>
}<BR>
<BR>
Here are the things you have to get right:<BR>
<BR>
1. The operator&lt;&lt; function can't be a member of your own class, because the left-hand operand is an ostream object.<BR>
<BR>
2. The first parameter has to be a reference-type parameter because you want os to be the very same stream object that the operator is applying to, and not a copy of it. Inside the function, os is an alias, another name, for the original cout object.<BR>
<BR>
3. The return type has to be a reference to an ostream object, so that each application of &lt;&lt; will produce the same ostream object that was originally on the left-hand side, so the next &lt;&lt; will take it as its left-hand operand. This is why you can cascade the output operator.  <BR>
<BR>
4.  You have to be sure to return the ostream parameter object so that the cascading in #3 will work.<BR>
<BR>
See Winston, p. 199, &quot;How to overload the output operator&quot; for more discussion. <BR>
<BR>
The ostream class includes an overload of operator&lt;&lt; for every built-in type, as in:<BR>
<BR>
ostream&amp; operator&lt;&lt; (ostream&amp; os, int x)<BR>
{/* output an integer */}<BR>
<BR>
ostream&amp; operator&lt;&lt; (ostream&amp; os, double x)<BR>
{/* output a double */}<BR>
<BR>
ostream&amp; operator&lt;&lt; (ostream&amp; os, char * x)<BR>
{/* output a C string */}<BR>
<BR>
This is why output using the iostream library is type-safe - the compiler will make sure the right output function is called for the type of object you are outputting.<BR>
<BR>
<B>What about unary operators?<BR>
</B><BR>
Overloading unary operators works the same way, except there is only one parameter to the operator function when it is a non-member, and no parameters when it is a member.  For example, suppose we wanted the negation operator (!) to return true if a CoinMoney object was empty (all fields zero), and false otherwise.  We just define a nonmember function:<BR>
<BR>
bool operator! (CoinMoney m)<BR>
{<BR>
 return ( <BR>
 m.get_nickels() == 0 &amp;&amp; <BR>
 m.get_dimes() == 0 &amp;&amp; <BR>
 m.get_quarters() == 0 <BR>
 );<BR>
}<BR>
<BR>
or a member function:<BR>
<BR>
bool operator! ()<BR>
{<BR>
 return ( <BR>
 nickels == 0 &amp;&amp; <BR>
 dimes == 0 &amp;&amp; <BR>
 quarters == 0 <BR>
 );<BR>
}<BR>
<BR>
The istream and ostream classes typically have a similar definition of operator! to implement the test of whether a stream is good by checking the stream object, as in:<BR>
<BR>
if(!my_file) {/* oops! something is wrong! */}<BR>
<BR>
<BR>
<B>Conversion operators.<BR>
</B><BR>
The compiler sometimes needs convert an object of one type to another.  In the CoinMoney example, we might want to treat a CoinMoney object as a single numeric value, say as a double, so we could write:<BR>
<BR>
tax = .06 * m1;<BR>
<BR>
where we want to multiply .06 times the value of m1.  If we tell the compiler how to turn a CoinMoney object into a double, then the compiler can just generate the rest of the code like it usually does.  We would write (say as a member function):<BR>
<BR>
operator double ()<BR>
{<BR>
 return value();<BR>
}<BR>
<BR>
<BR>
Conversion operators are not used very often, because you can get nasty surprises.  Notice for example that if we had both this conversion operator and the operator* (double, CoinMoney) we now have an ambiguity in how the compiler should analyze the above tax statement.  So use these <B>very</B> sparingly.<BR>
<BR>
The istream and ostream classes typically contain a conversion operator to convert a istream or ostream object into a bool, so that you can write:<BR>
<BR>
if(my_input_file) {/* everything is good! */}<BR>
<BR>
You aren't testing for whether the humongous istream object is true or nonzero - it's a hundred+ bytes jammed full of data!  But the function<BR>
<BR>
operator bool (istream&amp; is) {whatever}<BR>
<BR>
computes a true/false value based on the stream state bits, thereby allowing you to treat the stream object as a single true/false value.<BR>
<BR>
<B>For the curious: A tidbit about object conversions <BR>
</B><BR>
Sometimes a constructor function plays the role of a conversion function.<BR>
For example, consider the following code sketch:<BR>
<BR>
class Thing<BR>
{<BR>
blah blah<BR>
};<BR>
<BR>
class Glob<BR>
{<BR>
 Glob(Thing t);<BR>
blah blah<BR>
};<BR>
<BR>
void foo(Glob g);<BR>
<BR>
....<BR>
Thing my_thing;<BR>
...<BR>
foo(my_thing);<BR>
...<BR>
<BR>
You can't call foo with a Thing as an argument; foo requires a Glob. But the compiler cleverly notices that it can construct a Glob from a Thing, so it compiles the call as if the programmer had written:<BR>
<BR>
Glob my_glob(my_thing);<BR>
<BR>
foo (my_glob);<BR>
<BR>
Often this is exactly what you want. Sometimes it is a source of mysterious errors.  The keyword &quot;explicit&quot; is used to prevent this use of a constructor.<BR>
<BR>
</P>
</BODY>
</HTML>

