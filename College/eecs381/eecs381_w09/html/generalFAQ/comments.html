<!--This file created by AppleWorks HTML Filter 6.0-->
<HTML>
<HEAD>
<META NAME=GENERATOR CONTENT="AppleWorks HTML Filter 6.0">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=macintosh">
<TITLE>comments</TITLE>
</HEAD>
<BODY  >

<P ALIGN=CENTER><FONT SIZE=4><B>Why and How You Should Comment Your Code<BR>
David Kieras, EECS Department<BR>
September, 2003<BR>
</B></FONT></P>

<P><BR>
<BR>
<B>Why comment?<BR>
<BR>
</B>The purpose of comments is to help yourself to understand your own code, and especially to help other people read and understand your code. <BR>
<BR>
Experience shows that grading comments for quality in detail is difficult, and computer grading of comments is technically not really possible.  But we can grade whether your comments are generally adequate, and whether you have enough comments to be reasonable. <BR>
<BR>
Here is how we will enforce commenting requirements: If you ask for help with your code, and it is poorly commented and hard to read, we reserve the right to tell you to go away until you have commented it and cleaned it up, especially if there are people waiting for our help.  <BR>
<BR>
Comments are there to help people read the code, so if you leave them out, it will be *your* problem, not ours!  And if you don't put comments in your code from the beginning, chances are it will be harder for you to write the code. So put comments in while you are writing the code, when they will help you, and help us to help you; don't leave them until the end! <BR>
<BR>
Then if we are assessing the project for quality, if you have commented your code in a way that helps develop the code and debug it, you should be in good shape when we assess the quality of your code.<BR>
<BR>
<B>How comment?<BR>
</B><BR>
What should your comments be like, and how long should they be? Many textbooks seem to go overboard on this. But the working assumption  in industry is that the code is going to be read by a programmer familiar with the language and with the specifications or purpose of the program.  So comments should be limited to saying things that are not obvious from the code or from external documents. Also, by using good function and variable names, and the expressiveness allowed by the syntax of the language, one can say a lot about the code in the code itself.  <BR>
<BR>
Each function should have a short comment before it that says what the purpose of the function is, or summarizes its operation, or key design decisions or assumptions involved in it.  Note that the result or effect of a function is usually less obvious than what its inputs are, which the parameter names and types should make obvious. <BR>
<BR>
Then inside the function, use brief comments for anything that would slow the reader down - e.g. if it took you a while to figure out how to write the code, it would take a reader a long time to figure out what the code is doing, so you tell them up-front with a few selected comments. The best comments are essentially an outline for what the code is supposed to do. An old programmer's trick is to write the comments first, and then fill in the actual code! Writing the comments first ensures that they actually describe important ideas about the code, and so help both you and the reader. <BR>
<BR>
But never write comments that are totally synonymous with the code, like<BR>
<FONT SIZE=2><BR>
 // add one to i<BR>
 i++;<BR>
 // call foo with i<BR>
 foo(i);<BR>
 // go back to caller<BR>
 return;<BR>
</FONT><BR>
Such comments are a waste of time - unless you are really at the earliest stage of learning. If so, be sure to eliminate them when you no longer need them.<BR>
<BR>
<B>Some real examples<BR>
</B><BR>
Below is a function from some of my own research code, that took a non-trivial amount of time to design. My research colleagues who use my code have often given me positive feedback about the comments, so I must be doing something right; if anything, I comment somewhat too heavily.<BR>
<BR>
Anyway, in this example, I am assuming that the reader knows the Standard Library container classes, which are used everywhere in the project, and the #includes should tell the reader this. It would be crazy to document in every function how these Standard Library things work.  <BR>
<BR>
But I wanted to make sure that when *I* or someone else has to look at this code, we don't have to figure the design decisions out all over again. We can read the comments and see critical design issues and the basic logic of the function without puzzling over any of the details in the code. As an example of the code explaining itself, the &quot;const Binding_set&amp; bs&quot; in the parameter list tells the reader that the input is a &quot;binding set&quot; that is neither copied nor modified. While the name &quot;bs&quot; for the parameter isn't very informative, it is the only binding set in the picture, so it's pretty clear that bs is the binding set that is being removed.<BR>
<BR>
<FONT SIZE=2>/*<BR>
Remove a binding set by finding it and removing it.<BR>
add_binding_set ensured each binding set is unique, so<BR>
removal here does not have to check for duplication.<BR>
Return true if a change was made.<BR>
*/<BR>
bool Binding_set_list::remove_binding_set(const Binding_set&amp; bs)<BR>
{<BR>
 // if list is empty, no removal, no change<BR>
 if (binding_set_list.size() == 0)<BR>
  return false;<BR>
 // search nonempty list for binding set<BR>
 Binding_set_list_t::iterator pos = <BR>
  find(binding_set_list.begin(), binding_set_list.end(), bs);<BR>
 if (pos == binding_set_list.end())<BR>
  return false; // not present, no change<BR>
 <BR>
 binding_set_list.erase(pos);<BR>
 return true; // changed<BR>
}<BR>
</FONT><BR>
<BR>

<HR>
Understanding the purpose of even a very simple function can be helped by a comment, to spare the reader from having to parse the code.  Another example from my own code:<BR>
<BR>
<FONT SIZE=2>// output a pair in parentheses, with a colon after the varname<BR>
ostream&amp; operator&lt;&lt; (ostream&amp; os, const Binding_pair&amp; bp)<BR>
{<BR>
 os &lt;&lt; '(' &lt;&lt; bp.get_var_name() &lt;&lt; ':' &lt;&lt; bp.get_var_value() &lt;&lt; ')';<BR>
 return os;<BR>
}<BR>
</FONT><BR>
Here is another short example, showing a couple of comments that explain how the code deals with obscure facts about the math library that might otherwise stump the reader:<BR>
<BR>
<FONT SIZE=2>// construct a Polar_vector from a Cartesian_vector<BR>
Polar_vector::Polar_vector(const Cartesian_vector&amp; cv)<BR>
{<BR>
 r = sqrt((cv.delta_x * cv.delta_x) + (cv.delta_y * cv.delta_y));<BR>
 // atan2 will return negative angle for Quadrant III, IV.<BR>
 theta = atan2 (cv.delta_y, cv.delta_x);<BR>
 if (theta &lt; 0.)<BR>
  theta = 2. * GU_pi + theta; // normalize theta positive<BR>
}<BR>
<BR>
</FONT><BR>
<B>Note:</B> I haven't spruced this code up for other people yet! So if I find it helpful to comment my own code in this way for myself, chances are you will too!<BR>
<BR>
Finally, here is a long example, in which a complex algorithm is being used that I learned for the first time when I wrote this function some years ago, so the comments helped me understand what was going on; recently I had to revisit this code when I moved it into a new environment. My original comments helped me make sense of it, greatly simplifying the modifications I had to make. Howver, because it presupposes a reader willing to work at it, not all the complexities are commented on.<BR>
<BR>
<FONT SIZE=1>/*<BR>
Calculate the line that intersects a rectangle through its center, using a specialization <BR>
of the Cohen-Sutherland clipping algorithm (see Foley, van Damm, Feiner, &amp; Hughes).<BR>
<BR>
The start-to-center line goes from the start point P0 to the end point P1, <BR>
which is the center of the rectangular target region, whose boundaries are <BR>
min_edges.x, max_edges.x, min_edges.y, max_edges.y.<BR>
<BR>
Since P1 is always inside the rectangle, we check only for whether P0 is also inside,<BR>
and then which edge of the rectangle the line crosses, and compute the point of<BR>
intersection.<BR>
<BR>
clipped_line is the line ending in the center that intersects the edge of rectangle.<BR>
return true if starting point is outside and d and s values are valid; false otherwise<BR>
*/<BR>
<BR>
bool compute_center_intersecting_line(const Line_segment&amp; start_to_center, const Size rect_size, Line_segment&amp; clipped_line)<BR>
{<BR>
 // the start of the line is p0, the starting point, and will get moved to <BR>
 // points of intersection during the computation<BR>
 Point p0(start_to_center.get_p1());<BR>
<BR>
 // the end of the line is p1, the center of the target, and stays fixed.<BR>
 const Point p1(start_to_center.get_p2()); <BR>
<BR>
 // max and min_edges are the boundaries of the target rectangle<BR>
 // max edges are the top right coordinates<BR>
 Point max_edges(p1.x + rect_size.h/2, p1.y + rect_size.v/2);<BR>
 // min edges are the lower left coordinates<BR>
 Point min_edges(p1.x - rect_size.h/2, p1.y - rect_size.v/2);<BR>
<BR>
 // Where does the line p0-p1 intersect the rectangle? <BR>
 // Calculate intersection accordingly.<BR>
 // if the point is not outside, then start point must be inside the rectangle, <BR>
 // and no movement should be made<BR>
 <BR>
 Point p; // point of intersection<BR>
 bool top, bottom, right, left;<BR>
 bool first = true;<BR>
<BR>
 while(true) {<BR>
 top = bottom = left = right = false;<BR>
 // calculate where p0 is outside<BR>
 if (p0.y &gt; max_edges.y) {<BR>
  top = true;<BR>
  }<BR>
 else if (p0.y &lt; min_edges.y) {<BR>
  bottom = true;<BR>
  }<BR>
 if (p0.x &gt; max_edges.x) {<BR>
  right = true;<BR>
  }<BR>
 else if (p0.x &lt; min_edges.x) {<BR>
  left = true;<BR>
  }<BR>
 // if p0 is not outside, we are done<BR>
 // If it was the first value of p0, then starting point was inside, <BR>
 // and result is invalid<BR>
 // otherwise stop and compute the final result<BR>
 // if p0 is still outside, continue the computation with the new value<BR>
 if (!(top || bottom || right || left)) {<BR>
  if(first)<BR>
   return false;<BR>
  else<BR>
   break;<BR>
  }<BR>
 else<BR>
  first = false;<BR>
 // Where does the line intersect the rectangle?<BR>
 // On the top<BR>
 if (top) {<BR>
  p.x = p1.x + (p0.x - p1.x) * (max_edges.y - p1.y)/(p0.y - p1.y);<BR>
  p.y = max_edges.y;<BR>
  }<BR>
<BR>
 // On the bottom<BR>
 else if (bottom) {<BR>
  p.x = p1.x + (p0.x - p1.x) * (min_edges.y - p1.y)/(p0.y - p1.y);<BR>
  p.y = min_edges.y;<BR>
  }<BR>
<BR>
 // On the right<BR>
 else if (right) {<BR>
  p.x = max_edges.x;<BR>
  p.y = p1.y + (p0.y - p1.y) * (max_edges.x - p1.x)/ (p0.x - p1.x);<BR>
  }<BR>
<BR>
 // On the left<BR>
 else if (left) {<BR>
  p.x = min_edges.x;<BR>
  p.y = p1.y + (p0.y - p1.y) * (min_edges.x - p1.x)/ (p0.x - p1.x);<BR>
  }<BR>
 <BR>
 // move p0 to the point of intersection and repeat<BR>
 p0 = p;<BR>
 } // main loop<BR>
 // return the line segment between the intersection and the center<BR>
 clipped_line = Line_segment(p0, p1);<BR>
 return true;<BR>
}<BR>
<BR>
</FONT><BR>
</P>

<HR>
<P>

<P ALIGN=CENTER><I>#</P>
</I></P>
</BODY>
</HTML>

