<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="949.54">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; text-align: center; font: 14.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 10.0px Courier}
  </style>
</head>
<body>
<p class="p1"><b>Project 2 Frequently Asked Questions</b></p>
<p class="p1"><b>Updated 2/10/10</b></p>
<p class="p1"><b>The most recent items appear first.</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>My project seems to be working just fine but it is still failing the Ordered_list standalone test.<span class="Apple-converted-space">  </span>Why is that?</b></p>
<p class="p3">Unless you have tested each and every member function and operator<span class="Apple-converted-space">  </span>of this container and its iterators, you haven't fully tested it. See the essay on testing on the course home page for some ideas.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3"><b>Ditto with my String class.</b></p>
<p class="p3">Ditto with the testing.</p>
<p class="p2"><br></p>
<p class="p3"><b>My code might still have some problems, but why does it fail the "Your globals, my others" test - it passes the compile.</b></p>
<p class="p3">The standalone component tests are supposed to test your single component. The whole-program component tests really make sense only if your whole-program code is working or almost working. This test, and the other component tests in which the whole program is assembled, uses the variety scenario that involves restoring a file that the normal sample test would save. So if it fails the sample test, and the variety test, when only your code is involved, you should not expect<span class="Apple-converted-space">  </span>to pass these component<span class="Apple-converted-space">  </span>tests.<span class="Apple-converted-space">  </span>The fact that your code passes the compile means that the declarations of the globals are probably correct, which is the actual point of this particular test.</p>
<p class="p2"><br></p>
<p class="p3"><b>My implementation of String disagrees with yours in the demo in which "Tom" is compared to "Dick." Is there something wrong with your demo?</b></p>
<p class="p3">Understanding this is very important, which is why it is in the demo - to uncover a possible fundamental misunderstanding. Here is the answer, which are questions that you need to figure out:</p>
<p class="p2"><br></p>
<p class="p3">What <b><i>exactly</i></b> is that comparison doing? What is being compared? How is your String comparison involved?</p>
<p class="p2"><br></p>
<p class="p3">If you are still puzzled, the handout on Operator Overloading will help.</p>
<p class="p2"><br></p>
<p class="p3"><b>I'm getting a confusing compiler error message in my declaration of Collection, where I declare the Ordered_list container, something like:</b></p>
<p class="p4">Ordered_list&lt;Record *&gt; members(Record_ptr_compare);</p>
<p class="p3"><b>The same declaration in a function like the demo causes no problem. What's wrong?</b></p>
<p class="p3">Compiler error messages are sometimes very confusing if you do something that is off the wall. In this case, you are trying to initialize a member variable in the class declaration instead of the constructor, which is pretty far off the wall - that's what constructor functions and constructor initializers are for - to initialize member variables when an object is created. You couldn't do this with a String (or std::string) member variable in the class declaration either:</p>
<p class="p2"><br></p>
<p class="p4">String greeting("hello"); // can't initialize it here!</p>
<p class="p2"><br></p>
<p class="p3">Note that you can initialize a <i>static const member variable of integral type to a constant</i> in the class declaration, but that's a weird special case - and is possible because only one instance of a static member variable exists. This doesn't apply to your members container - each collection has its own set of members.</p>
<p class="p2"><br></p>
<p class="p3"><b>What's with the filename of ".." in the errors sample? I could open it with my program.</b></p>
<p class="p3">The purpose of that part of the sample was to demonstrate a file-opening failure in the sA command. A filename that produces an error on opening for output is not easy to come by, and it is platform specific. This filename is Unix's directory file (try doing "ls - a" in a Unix shell). It can be read, but is write-protected. So on a Unix machine, this filename will produce an error when opened for output, but not for input.</p>
<p class="p2"><br></p>
<p class="p3"><b>I get a really confusing error message in my Ordered_list.h file for the line of code:</b></p>
<p class="p5">template&lt;typename T&gt;</p>
<p class="p5">Ordered_list&lt;T&gt;::Iterator Ordered_list&lt;T&gt;::find(const T&amp; probe_datum) const</p>
<p class="p2"><br></p>
<p class="p3"><b>The message from gcc is:</b></p>
<p class="p3">error: expected constructor, destructor, or type conversion before 'Ordered_list'</p>
<p class="p3"><b>What does this mean?</b></p>
<p class="p3">This message from gcc means that the compiler is basically confused - what it is unhappy about is "Iterator" - it doesn't know what this is. Other compilers will complain about whether "Iterator" is a <i>dependent</i> type which is a much better clue.</p>
<p class="p2"><br></p>
<p class="p3">The problem is the ambiguity in template members that Stroustrup mentions (confusingly) and that the template lecture notes clarifies.</p>
<p class="p2"><br></p>
<p class="p3">Basically, the type of thing that "Iterator" refers to <i>depends</i> on what is in Ordered_list&lt;T&gt; when it gets instantiated - it might be a static member, for example. In this case, it is the name of a type, which we know, but the compiler has to be careful about - it is possible, through specialization or partial specialization, that Ordered_list might be instantiated in more than one way, and "Iterator" might be something different.</p>
<p class="p2"><br></p>
<p class="p3">But since you know that "Iterator" is the name of a type, you need to tell the compiler that the "Iterator" in Ordered_list&lt;T&gt; is the name of a type. The "typename" keyword was added to the language for this purpose. Try:</p>
<p class="p2"><br></p>
<p class="p5">template&lt;typename T&gt;</p>
<p class="p5">typename Ordered_list&lt;T&gt;::Iterator Ordered_list&lt;T&gt;::find(const T&amp; probe_datum) const</p>
<p class="p2"><br></p>
<p class="p3">Note that in olden times, compilers would just <i>assume</i> that Iterator was the name of a type, and not complain, but as template programming got fancier, people realized that there was a more serious problem here, but we got new kind of compile error from the fix.</p>
<p class="p2"><br></p>
<p class="p3"><b>My version of String doesn't match your demo after the statement:</b></p>
<p class="p3"><b>target = target + "abc";</b></p>
<p class="p3"><b>Shouldn't the allocation be 8, not 4?</b></p>
<p class="p3">First, be sure you understand <i>exactly</i> what happens in that statement, step by step, then double-check your code against the specs in the skeleton String.h file.</p>
<p class="p2"><br></p>
<p class="p3"><b>The compiler gives me error messages when I try to overload the output (or input operator) or use one of them.</b></p>
<p class="p3">Make sure you have included the correct Library header file so that the compiler knows about istream, ostream, ifstream, etc. &lt;iosfwd&gt; contains incomplete/forward declarations, and often is all you need to #include in your header file. For the .cpp file, you need &lt;iostream&gt; for the normal input/output operators, and &lt;fstream&gt; if you are using a file stream.</p>
<p class="p2"><br></p>
<p class="p3"><b>I'm getting some really confusing error messages that seem to have something to do with my header file - as in String.h.</b></p>
<p class="p3">Check that you are following the C++ Header File Guidelines, and also if you are #including something from the C Standard Library, that you are doing it with the C++ version of the header - like &lt;cstring&gt; instead of &lt;string.h&gt; - which wraps the C Library declarations in the std:: namespace.</p>
<p class="p2"><br></p>
<p class="p3"><b>Same question as above, but I forgot to tell you that I am using g++ on Unix or Linux.</b></p>
<p class="p3">Take a quick look and see if your building directory has a file with a second ".gch" extension, as in "String.h.gch". This is a gcc "precompiled header", used to speed up compile times. Once it is present, the compiler will use it instead of the original .h file in #includes, meaning that changes to your header file will be ignored, making you doubt your sanity and the basic goodness of creation.</p>
<p class="p2"><br></p>
<p class="p3">It probably got created because you accidentally compiled a naked header file all by itself, as in:</p>
<p class="p3">g++ String.h</p>
<p class="p3">which you normally don't do - you normally give gcc only the source (.c or .cpp) files. Anyway, delete the .gch file and the compiler should then revert to using your .h file.</p>
<p class="p2"><br></p>
<p class="p3"><b>Any more suggestions about confusing error messages that might be due to header file problems?</b></p>
<p class="p3">Make sure the header file itself has only correct contents. Do this compiling it by itself, but as if it were included. For example, create a little file called "testheader.cpp" containing only:</p>
<p class="p2"><br></p>
<p class="p3">#include "String.h" // the header file to be tested</p>
<p class="p2"><br></p>
<p class="p3">Then "g++ testheader.cpp" will do the compile, then it will complain because it can't find a main function, so the link will fail, and there will be nothing you need to clean up. But if you get compile errors on the header file contents, then fix them and repeat until this test produces no compile errors. Then go back and do the original complete compile - any errors will be due only to things in the .cpp file(s).</p>
<p class="p2"><br></p>
<p class="p3"><b>What compiler, version, and options are being used by the autograder?</b></p>
<p class="p3">g++ 4.1.2, with options the same as in the supplied makefile.</p>
<p class="p3">Before submitting your code, you should upload to a CAEN workstation and try compiling your code with g++ 4.1.2 or later with the same compiler options. Check for a match on at least the samples to help detect any discrepancies.</p>
</body>
</html>
