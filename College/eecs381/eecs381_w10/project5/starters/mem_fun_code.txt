/*
The following is taken from Metrowerks' <functional> to illustrate how member function
adapters are implemented. 

You can make up your own versions of these adapters that will allow you to use
algorithms like for_each on a container of smart pointers. For example:

	for_each(sim_obj_ptrs.begin(), sim_obj_ptrs.end(), Smart_mem_fun(&Sim_object::describe));
	for_each(sim_obj_ptrs.begin(), sim_obj_ptrs.end(), shared_mem_fun(&Sim_object::describe));

Hint: It is very easy if you first understand how these templates work -
see the Handout on How Adapters and Binders Work.
*/


// mem_fun_t

template <class S, class T>
class mem_fun_t
	: public unary_function<T*, S>
{
public:
	explicit mem_fun_t(S (T::*mf_)()) : mf(mf_) {}
	S operator()(T* p) const {return (p->*mf)();}
private:
	S (T::*mf)();
};

// mem_fun1_t

template <class S, class T, class A>
class mem_fun1_t
	: public binary_function<T*, A, S>
{
public:
	explicit mem_fun1_t(S (T::*mf_)(A)) : mf(mf_) {}
	S operator()(T* p, A x) const {return (p->*mf)(x);}
private:
	S (T::*mf)(A);
};

// mem_fun

template<class S, class T>
inline
mem_fun_t<S, T>
mem_fun(S (T::*f)())
{
	return mem_fun_t<S, T>(f);
}

template<class S, class T, class A>
inline
mem_fun1_t<S, T, A>
mem_fun(S (T::*f)(A))
{
	return mem_fun1_t<S, T, A>(f);
}

// const_mem_fun_t

template <class S, class T>
class const_mem_fun_t
	: public unary_function<const T*, S>
{
public:
	explicit const_mem_fun_t(S (T::*mf_)() const) : mf(mf_) {}
	S operator()(const T* p) const {return (p->*mf)();}
private:
	S (T::*mf)() const;
};

// const_mem_fun1_t

template <class S, class T, class A>
class const_mem_fun1_t
	: public binary_function<const T*, A, S>
{
public:
	explicit const_mem_fun1_t(S (T::*mf_)(A) const) : mf(mf_) {}
	S operator()(const T* p, A x) const {return (p->*mf)(x);}
private:
	S (T::*mf)(A) const;
};

// mem_fun

template <class S, class T>
inline
const_mem_fun_t<S, T>
mem_fun(S (T::*f)() const)
{
	return const_mem_fun_t<S, T>(f);
}

template <class S, class T, class A>
inline
const_mem_fun1_t<S, T, A>
mem_fun(S (T::*f)(A) const)
{
	return const_mem_fun1_t<S, T, A>(f);
}

